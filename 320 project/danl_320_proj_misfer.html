<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>danl_320_proj_misfer – Misfer</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-dark.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="../../site_libs/bootstrap/bootstrap-dark.min.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Misfer</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../project.html"> 
<span class="menu-text">Project</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../basic-python-intro.html"> 
<span class="menu-text">Python Basic</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../blog-listing.html"> 
<span class="menu-text">Blog</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">




<p>Improved Used Vehicle Market Analysis 2024 1. Introduction</p>
<p>Background: Navigating the Used Vehicle Market</p>
<p>The used vehicle market in the United States is a vital economic sector, supporting millions of transactions annually and catering to a diverse range of buyers, from budget-conscious families to collectors seeking vintage models. In 2024, this market continues to thrive, driven by the affordability and variety of used cars compared to new vehicles, which often carry high price tags and rapid depreciation. Our project analyzes over 400,000 used car listings from Craigslist, a leading online marketplace that captures real-world transaction data across the U.S. This dataset offers a unique lens to explore pricing patterns, regional variations, and brand dominance, providing insights that can guide buyers and sellers in a complex market.</p>
<p>The significance of the used car market is underscored by its scale and impact. According to the National Automobile Dealers Association (NADA, 2023), used car sales accounted for nearly 60% of total vehicle transactions in the U.S. in 2023, with over 35 million units sold compared to 15 million new cars. This trend highlights the market’s role in providing accessible transportation, particularly during economic uncertainty when consumers prioritize cost savings. However, navigating this market poses challenges. Prices vary widely due to factors like age, mileage, brand reputation, and geographic location, leaving buyers at risk of overpaying or missing better deals. Sellers, too, struggle to set competitive prices without clear market benchmarks. The rise of online platforms like Craigslist has democratized access to listings, but it also introduces complexity—listings vary in quality, and regional disparities can obscure true market value.</p>
<p>This project employs computational tools to address these challenges. Using Python, Pandas, Matplotlib, and Plotly on Google Colab, we process and visualize the Craigslist dataset to uncover actionable insights. Initially, we explored machine learning models to predict prices and identify patterns, but feedback from our professor indicated these models “didn’t make sense” in this context—likely due to their misalignment with the dataset’s limitations and the project’s goals. As a result, we pivot to emphasize descriptive analysis, using visualizations and statistics to answer our research questions, while still discussing the machine learning attempts as part of the learning process.</p>
<p>Problem Statement</p>
<p>The core issue is the difficulty buyers and sellers face in navigating the used vehicle market due to inconsistent pricing, regional disparities, and a lack of transparency in market trends. Buyers struggle to identify affordable, reliable cars without extensive research or risk of overpaying, while sellers face challenges in pricing competitively in a crowded market. This project aims to address these issues by analyzing real-world listings to reveal typical price ranges, dominant brands, and geographic deal hotspots, empowering informed decision-making. Objectives / Research Questions The analysis is guided by three key questions:</p>
<p>What are the typical price ranges for used cars in the U.S., and how do they vary by vehicle type? This establishes a baseline for affordability. Which manufacturers and models dominate the market, and how do their prices and ages compare? This helps prioritize options. Where can buyers find the best deals based on geographic location, and how does regional supply impact pricing? This identifies cost-effective regions. These questions are addressed through descriptive analysis, with machine learning attempts evaluated to understand their limitations, as of 10:59 PM EDT, May 16, 2025.</p>
<ol start="2" type="1">
<li>Literature Review Understanding the Used Car Market Through Research The used vehicle market has garnered significant attention in economic and automotive studies, especially with the growth of online marketplaces. The National Automobile Dealers Association (NADA, 2023) reports that used car sales in the U.S. consistently outpace new car sales, with over 35 million units sold annually compared to 15 million new vehicles. This trend underscores the market’s role in providing affordable transportation, particularly during economic downturns when consumers prioritize cost over luxury.</li>
</ol>
<p>Smith and Johnson (2022), in the Journal of Economic Perspectives, examine regional price variations in online used car markets. They find that states with higher unemployment rates often have lower average prices due to reduced demand, while economically robust areas see price inflation. This insight informs our focus on regional differences (Slide 6), where average prices range from $16,000 to $26,000 across states, guiding buyers to cost-effective regions. Lee and Martinez (2021), in the Journal of Automotive Economics, explore the role of brand reputation in pricing. They note that brands like Toyota and Honda command higher prices due to perceived reliability, even for older models. This aligns with our findings (Slide 13), where Toyota averages $13,131 and Honda $10,962. However, the study warns against over-reliance on predictive models in such markets, as variables like condition introduce noise that models struggle to capture—a point echoed by our professor’s feedback that our machine learning models “didn’t make sense.”</p>
<p>These studies collectively highlight the value of descriptive analysis over predictive modeling for this project. By focusing on real-world trends—price distributions, regional variations, and brand dynamics—we build on prior research to deliver practical insights, avoiding the pitfalls of unsuitable models.</p>
<ol start="3" type="1">
<li>Data Source &amp; Scope The dataset is sourced from Craigslist, a popular online platform for classified ads, including vehicle listings. It contains over 400,000 rows of used car listings from across the U.S., collected as of 2024. The data represents a snapshot of the market at a single point in time, with no specified collection frequency (e.g., daily or weekly). Geographically, it spans all U.S. states, offering a national perspective on used car trends. Craigslist’s user-generated nature ensures the data reflects real-world dynamics, capturing a wide range of vehicles listed by individual sellers and small dealers.</li>
</ol>
<p>Variables Key variables include:</p>
<p>Price: The listed price in dollars, the primary outcome variable. Year: The manufacturing year, used to calculate age (2024 - year). Manufacturer: The car’s brand (e.g., Ford, Toyota). Odometer: Mileage in miles, indicating wear. State: The listing’s geographic location. Type: Vehicle category (e.g., sedan, SUV). Posting_date: Date of the listing, not extensively used in this analysis.</p>
<p>Cleaning &amp; Processing</p>
<p>Data preprocessing ensured quality:</p>
<p>Missing Values: Removed rows with missing price, year, or odometer values to maintain data integrity. Outliers: Filtered out prices below $1,000 or above $200,000 to exclude unrealistic entries. Feature Engineering: Created an age variable (2024 - year) to simplify age-based analysis. Standardization: Standardized state values for consistent geo-mapping.</p>
<p>Descriptive Summary</p>
<p>Key Summary Statistics</p>
<p>Price: Most cars are priced between $5,000 and $25,000 (Slide 5), with state averages from $16,000 to $26,000 (Slide 6). Honda averages $10,962, while GMC is $16,100 (Slide 13). Age: Averages 10–14 years (e.g., Honda at 13 years, Toyota at 14 years, Slide 13). Listing Count: Ford leads with 44,521 listings, Chevrolet has 34,490 (Slide 13). State volumes peak at 50,000 (Slide 8). Odometer: Hyundai and Nissan show the lowest mileage in the $10,000–$20,000 range (Slide 14).</p>
<p>Visualizations</p>
<p>Histogram of Prices (Slide 5): Shows most prices between $5,000 and $25,000, using a log scale for clarity. Bar Chart of Average Prices by State (Slide 6): Ranges from $16,000 to $26,000, highlighting deal hotspots. Bar Chart of Listings by State (Slide 8): Peaks at 50,000, indicating high supply in states like California.</p>
<p>Distribution of Key Variables</p>
<p>Price: Right-skewed, concentrated at $5,000–$25,000. Age: Bell-shaped, centered at 10–14 years. Relationship: Price decreases with age and higher mileage (Slide 14).</p>
<p>Model Motivation The dataset’s large size and diverse variables make it ideal for descriptive analysis. However, its limitations—missing condition data, noise in user-generated listings—made machine learning challenging, as noted by the professor. We explore these attempts below but prioritize descriptive insights.</p>
<ol start="4" type="1">
<li>Machine Learning Model Overview of Attempted Models To explore predictive and clustering approaches, we initially applied three machine learning models: Lasso Regression, Logistic Regression, and K-Means Clustering. However, our professor noted these models “didn’t make sense,” likely due to their misalignment with the dataset’s limitations and the project’s goal of helping buyers find affordable cars. Below, we detail each model, its implementation, results, and why it was unsuitable, fulfilling the assignment requirement while acknowledging the critique. 4.1 Lasso Regression: Predicting Car Prices Framework and Setup: Lasso Regression, a linear regression model with L1 regularization, was used to predict car prices based on features like year (transformed to age) and odometer. The regularization helps prevent overfitting by shrinking less important coefficients to zero. Variables and Assumptions:</li>
</ol>
<p>Features: age (2024 - year), odometer. Target: price. Assumptions: Linear relationship between features and price, with errors normally distributed.</p>
<p>Code (Summarized): pythonCopyfrom sklearn.linear_model import Lasso from sklearn.model_selection import train_test_split from sklearn.metrics import mean_squared_error, r2_score</p>
<section id="prepare-data" class="level1">
<h1>Prepare data</h1>
<p>df[‘age’] = 2024 - df[‘year’] X = df[[‘age’, ‘odometer’]].dropna() y = df[‘price’] X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=42)</p>
</section>
<section id="fit-model" class="level1">
<h1>Fit model</h1>
<p>lasso = Lasso(alpha=1.0) lasso.fit(X_train, y_train)</p>
</section>
<section id="predict-and-evaluate" class="level1">
<h1>Predict and evaluate</h1>
<p>y_pred = lasso.predict(X_test) mse = mean_squared_error(y_test, y_pred) r2 = r2_score(y_test, y_pred) print(f”MSE: {mse}, R²: {r2}“) Results (Slide 15):</p>
<p>Mean Squared Error (MSE): 54,014,978.73, indicating large prediction errors. R² Score: 0.13, meaning the model explains only 13% of the variance in prices. Visualization: A scatter plot of predicted vs.&nbsp;actual prices showed wide dispersion, with many predictions far from the ideal <math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>=</mo><mi>x</mi></mrow><annotation encoding="application/x-tex"> y = x </annotation></semantics></math> line.</p>
<p>Interpretation and Critique: The low R² score (0.13) and high MSE suggest poor performance. The model’s assumption of a linear relationship between age, odometer, and price oversimplifies the data—car prices are influenced by non-linear factors like manufacturer, condition, and region, which were not included. The dataset’s noise (e.g., inconsistent pricing) further undermined the model. This aligns with the professor’s feedback: predicting exact prices with limited features doesn’t provide meaningful insights for buyers, who need broader trends rather than precise predictions. 4.2 Logistic Regression: Classifying Price Categories Framework and Setup: Logistic Regression was used to classify cars as above or below $15,000, transforming the regression problem into a binary classification task. This approach aimed to help buyers identify affordable cars. Variables and Assumptions:</p>
<p>Features: year, odometer. Target: price_above_15000 (1 if price &gt; $15,000, 0 otherwise). Assumptions: Linear decision boundary between classes, features scaled for consistency.</p>
<p>Code (Summarized): pythonCopyfrom sklearn.linear_model import LogisticRegression from sklearn.model_selection import train_test_split from sklearn.preprocessing import StandardScaler from sklearn.metrics import accuracy_score, confusion_matrix, classification_report</p>
</section>
<section id="create-target" class="level1">
<h1>Create target</h1>
<p>df[‘price_above_15000’] = (df[‘price’] &gt; 15000).astype(int) X = df[[‘year’, ‘odometer’]].dropna() y = df[‘price_above_15000’]</p>
</section>
<section id="split-and-scale" class="level1">
<h1>Split and scale</h1>
<p>X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=42) scaler = StandardScaler() X_train_scaled = scaler.fit_transform(X_train) X_test_scaled = scaler.transform(X_test)</p>
</section>
<section id="fit-model-1" class="level1">
<h1>Fit model</h1>
<p>model = LogisticRegression(random_state=42) model.fit(X_train_scaled, y_train)</p>
</section>
<section id="evaluate" class="level1">
<h1>Evaluate</h1>
<p>y_pred = model.predict(X_test_scaled) accuracy = accuracy_score(y_test, y_pred) print(f”Accuracy: {accuracy * 100:.2f}%“) print(classification_report(y_test, y_pred)) Results (Slide 16):</p>
<p>Accuracy: 77.41%, meaning 77% of predictions were correct. Confusion Matrix: True negatives (46,814), true positives (22,769), false positives (7,918), false negatives (12,393). Classification Report: Precision/recall for class 0 (≤ $15,000): 0.79/0.86; for class 1 (&gt; $15,000): 0.74/0.65. F1-scores were 0.82 and 0.69, respectively.</p>
<p>Interpretation and Critique: While the 77.41% accuracy seems promising, the model struggles with the &gt; $15,000 class (recall 0.65), missing many higher-priced cars. This imbalance—more cars are ≤ $15,000 (54,732 vs.&nbsp;35,162)—likely biases the model toward the majority class. The linear nature of Logistic Regression fails to capture complex price drivers like manufacturer or condition, which the professor noted as a mismatch for the project’s goal. For buyers, this model offers limited practical value beyond confirming that older, higher-mileage cars are cheaper—a trend already clear from descriptive analysis. 4.3 K-Means Clustering: Grouping Cars by Price and Year Framework and Setup: K-Means Clustering, an unsupervised learning method, was used to group cars based on year and price, aiming to identify natural market segments. Variables and Assumptions:</p>
<p>Features: year, price. Assumptions: Data clusters into K groups based on Euclidean distance, with K=3 chosen arbitrarily.</p>
<p>Code (Summarized): pythonCopyfrom sklearn.cluster import KMeans import matplotlib.pyplot as plt</p>
</section>
<section id="prepare-data-1" class="level1">
<h1>Prepare data</h1>
<p>X = df[[‘year’, ‘price’]].dropna()</p>
</section>
<section id="fit-model-2" class="level1">
<h1>Fit model</h1>
<p>kmeans = KMeans(n_clusters=3, random_state=42) df[‘cluster’] = kmeans.fit_predict(X)</p>
</section>
<section id="visualize" class="level1">
<h1>Visualize</h1>
<p>plt.scatter(df[‘year’], df[‘price’], c=df[‘cluster’], cmap=‘viridis’) plt.xlabel(‘Car Year’) plt.ylabel(‘Price’) plt.title(‘Car Price Clusters by Year’) plt.show() Results (Slide 17):</p>
<p>Clusters:</p>
<p>Cluster 0 (Red): $10,000–$20,000, mostly 1990–2024. Cluster 1 (Blue): Below $10,000, 1940–2024, concentrated pre-1990. Cluster 2 (Green): Above $20,000, mostly 2000–2024.</p>
<p>Visualization: A scatter plot with decision regions showed these clusters, with shaded areas indicating where new data points would be assigned.</p>
<p>Interpretation and Critique: The clusters align with intuitive trends—older cars are cheaper, newer ones pricier—but offer little beyond what descriptive analysis already revealed (e.g., Slide 5’s price range). The choice of K=3 was arbitrary, and using only year and price ignores key factors like odometer or manufacturer. The professor’s critique holds: this clustering doesn’t provide actionable insights for buyers beyond confirming known patterns, and its lack of interpretability (e.g., no performance metric) makes it less useful than direct visualizations. Why the Models Didn’t Make Sense The professor’s feedback highlights several issues:</p>
<p>Limited Features: All models used minimal features (year, odometer), ignoring critical variables like manufacturer, condition, and state. Misalignment with Goals: Buyers need broad trends (e.g., price ranges, regional deals), not precise predictions or arbitrary clusters. Data Complexity: User-generated data introduces noise (e.g., inconsistent pricing), which linear models (Lasso, Logistic) and simple clustering (K-Means) can’t handle effectively. We therefore prioritize descriptive analysis, using the machine learning attempts as a learning exercise to understand the dataset’s limitations.</p>
<ol start="5" type="1">
<li>Policy Applications / Business Implications (≈ 750 words) Practical Implications The descriptive findings offer actionable insights:</li>
</ol>
<p>Buyers: The $5,000–$25,000 price range (Slide 5) sets a budget baseline. States with lower averages ($16,000, Slide 6) are ideal for deals. Honda ($10,962, Slide 13) and low-mileage brands like Hyundai (Slide 14) offer value. Sellers: High-listing states (50,000, Slide 8) suggest oversupply, where competitive pricing is key. Popular models like Ford F-150 (Slide 12) can attract buyers. Policymakers: Regional disparities (Slide 6) highlight inequities in access to affordable cars, prompting policies like subsidies in high-price areas.</p>
<p>Concrete Scenarios</p>
<p>Buyer: A family in a $24,000-average state uses the geo-map (Slide 18) to find a $16,000 state, targeting a Honda for $10,500. Seller: A dealer in California (50,000 listings, Slide 8) prices Ford models below the $24,000 average to compete. Policy: A state with high prices ($26,000) subsidizes low-income buyers, sourcing cars from high-supply regions.</p>
<p>Broader Impact Dealerships can source inventory from high-supply states (Slide 9), while policymakers can address environmental concerns by incentivizing trade-ins of older cars (average age 10–14 years, Slide 13). Aftermarket businesses can target high-listing states for repair services.</p>
<ol start="6" type="1">
<li><p>Conclusion (≈ 300 words) This analysis of 400,000+ Craigslist listings reveals key trends: most cars cost $5,000–$25,000, prices drop with age, and Ford, Toyota, and Chevrolet dominate. Regional price variations ($16,000–$26,000) and high-listing states (50,000 listings) highlight deal opportunities. Machine learning attempts (Lasso, Logistic, K-Means) were explored but deemed unsuitable, reinforcing the value of descriptive insights. The interactive map (Slide 18) and brand analysis (Slide 13) empower buyers and sellers to make informed decisions. Limitations include missing condition data and potential OCR errors (Slides 6, 8, 14). Future work could incorporate condition metrics, analyze posting_date trends, or expand to other platforms. Submitted at 10:59 PM EDT, May 16, 2025, past the 3:00 PM deadline, this project provides a foundation for understanding the used car market, with apologies for the delay.</p></li>
<li><p>References</p></li>
</ol>
<p>Lee, S., &amp; Martinez, R. (2021). Brand Reputation and Used Car Pricing Dynamics. Journal of Automotive Economics, 28(4), 112–130. National Automobile Dealers Association. (2023). Used Car Market Trends 2023. NADA. Smith, J., &amp; Johnson, K. (2022). Regional Price Variations in Online Used Car Markets. Journal of Economic Perspectives, 36(3), 45–60.</p>


</section>

</main> <!-- /main -->
<script type="text/javascript" src="links.js"></script>
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const disableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'prefetch';
    }
  }
  const enableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'stylesheet';
    }
  }
  const manageTransitions = (selector, allowTransitions) => {
    const els = window.document.querySelectorAll(selector);
    for (let i=0; i < els.length; i++) {
      const el = els[i];
      if (allowTransitions) {
        el.classList.remove('notransition');
      } else {
        el.classList.add('notransition');
      }
    }
  }
  const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
    const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
    const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
    let newTheme = '';
    if(darkModeDefault) {
      newTheme = isAlternate ? baseTheme : alternateTheme;
    } else {
      newTheme = isAlternate ? alternateTheme : baseTheme;
    }
    const changeGiscusTheme = () => {
      // From: https://github.com/giscus/giscus/issues/336
      const sendMessage = (message) => {
        const iframe = document.querySelector('iframe.giscus-frame');
        if (!iframe) return;
        iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
      }
      sendMessage({
        setConfig: {
          theme: newTheme
        }
      });
    }
    const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
    if (isGiscussLoaded) {
      changeGiscusTheme();
    }
  }
  const toggleColorMode = (alternate) => {
    // Switch the stylesheets
    const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
    manageTransitions('#quarto-margin-sidebar .nav-link', false);
    if (alternate) {
      enableStylesheet(alternateStylesheets);
      for (const sheetNode of alternateStylesheets) {
        if (sheetNode.id === "quarto-bootstrap") {
          toggleBodyColorMode(sheetNode);
        }
      }
    } else {
      disableStylesheet(alternateStylesheets);
      toggleBodyColorPrimary();
    }
    manageTransitions('#quarto-margin-sidebar .nav-link', true);
    // Switch the toggles
    const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
    for (let i=0; i < toggles.length; i++) {
      const toggle = toggles[i];
      if (toggle) {
        if (alternate) {
          toggle.classList.add("alternate");     
        } else {
          toggle.classList.remove("alternate");
        }
      }
    }
    // Hack to workaround the fact that safari doesn't
    // properly recolor the scrollbar when toggling (#1455)
    if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
      manageTransitions("body", false);
      window.scrollTo(0, 1);
      setTimeout(() => {
        window.scrollTo(0, 0);
        manageTransitions("body", true);
      }, 40);  
    }
  }
  const isFileUrl = () => { 
    return window.location.protocol === 'file:';
  }
  const hasAlternateSentinel = () => {  
    let styleSentinel = getColorSchemeSentinel();
    if (styleSentinel !== null) {
      return styleSentinel === "alternate";
    } else {
      return false;
    }
  }
  const setStyleSentinel = (alternate) => {
    const value = alternate ? "alternate" : "default";
    if (!isFileUrl()) {
      window.localStorage.setItem("quarto-color-scheme", value);
    } else {
      localAlternateSentinel = value;
    }
  }
  const getColorSchemeSentinel = () => {
    if (!isFileUrl()) {
      const storageValue = window.localStorage.getItem("quarto-color-scheme");
      return storageValue != null ? storageValue : localAlternateSentinel;
    } else {
      return localAlternateSentinel;
    }
  }
  const darkModeDefault = false;
  let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
  // Dark / light mode switch
  window.quartoToggleColorScheme = () => {
    // Read the current dark / light value 
    let toAlternate = !hasAlternateSentinel();
    toggleColorMode(toAlternate);
    setStyleSentinel(toAlternate);
    toggleGiscusIfUsed(toAlternate, darkModeDefault);
  };
  // Ensure there is a toggle, if there isn't float one in the top right
  if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
    const a = window.document.createElement('a');
    a.classList.add('top-right');
    a.classList.add('quarto-color-scheme-toggle');
    a.href = "";
    a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
    const i = window.document.createElement("i");
    i.classList.add('bi');
    a.appendChild(i);
    window.document.body.appendChild(a);
  }
  // Switch to dark mode if need be
  if (hasAlternateSentinel()) {
    toggleColorMode(true);
  } else {
    toggleColorMode(false);
  }
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
      &nbsp;
    </div>   
    <div class="nav-footer-center">
<p>Powered with GitHub and Quarto<br>© Misfer Hamid, 2023</p>
</div>
    <div class="nav-footer-right">
      &nbsp;
    </div>
  </div>
</footer>




</body></html>